(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define('pulling', factory) :
	(global.Pulling = factory());
}(this, (function () { 'use strict';

function __extends(d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function assertArg(condition, message) {
    if (!condition) {
        throw TypeError("Invalid arguments: " + message);
    }
}
function polyfill() {
    Element.prototype.matches = Element.prototype.matches ||
        // @ts-ignore: Property does not exist
        Element.prototype.matchesSelector ||
        Element.prototype.webkitMatchesSelector ||
        // @ts-ignore: Property does not exist
        Element.prototype.mozMatchesSelector ||
        Element.prototype.msMatchesSelector ||
        // @ts-ignore: Property does not exist
        Element.prototype.oMatchesSelector;
    Object.entries = Object.entries || (function (obj) {
        return Object.keys(obj).map(function (key) { return [key, obj[key]]; });
    });
    Object.values = Object.values || (function (obj) {
        return Object.keys(obj).map(function (key) { return obj[key]; });
    });
    Object.assign = Object.assign || (function (first) {
        var objects = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            objects[_i - 1] = arguments[_i];
        }
        for (var _a = 0, objects_1 = objects; _a < objects_1.length; _a++) {
            var obj = objects_1[_a];
            for (var _b = 0, _c = Object.entries(obj); _b < _c.length; _b++) {
                var _d = _c[_b], key = _d[0], val = _d[1];
                first[key] = val;
            }
        }
        return first;
    });
    Array.prototype.includes = function includes(value) {
        return this.indexOf(value) !== -1;
    };
}

var timingFunctions = [
    'linear', 'ease', 'ease-in', 'ease-out',
    'ease-in-out', 'step-start', 'step-end',
];
var Pulling = /** @class */ (function () {
    function Pulling(options) {
        var _this = this;
        this.styles = {
            base: {
                menu: {},
                panel: {},
            },
            open: {
                menu: {},
                panel: {},
            },
            closed: {
                menu: {},
                panel: {},
            },
        };
        this.handlers = {
            beforeclose: [],
            closed: [],
            beforeopen: [],
            opened: [],
            touchstart: [],
            touchmove: [],
            touchend: [],
        };
        this.state = {
            opened: false,
            opening: false,
            closed: true,
            closing: false,
        };
        this.disabled = false;
        if (!Object.values(Pulling.modes).some(function (x) { return _this instanceof x; })) {
            throw TypeError('Calling this constructor is not allowed. ' +
                'Use `Pulling.create` instead');
        }
        var menu = options.menu, panel = options.panel, side = options.side, mode = options.mode, margin = options.margin, timing = options.timing, timingFunction = options.timingFunction, width = options.width, sensitivity = options.sensitivity, slope = options.slope, touch = options.touch;
        this.menu = menu;
        this.panel = panel;
        this.side = side || 'left';
        this.mode = mode || 'drawer';
        this.margin = margin || 25, this.timing = timing || 200;
        this.timingFunction = timingFunction || 'ease';
        this.width = width || 256;
        this.sensitivity = sensitivity || 0.25;
        this.slope = slope || 0.5;
        assertArg(this.menu instanceof Element, '`menu` must be of type `Element`');
        assertArg(this.panel instanceof Element, '`panel` must be of type `Element`');
        assertArg(this.side === 'left' || this.side === 'right', '`side` must be equal to "left" or "right"');
        assertArg(typeof this.margin === 'number', '`margin` must be of type "number"');
        assertArg(typeof this.timing === 'number', '`timing` must be of type "number"');
        assertArg(timingFunctions.includes(this.timingFunction), '`timingFunction`' + " must be one of " + timingFunctions.map(function (x) { return "\"" + x + "\""; }).join(', '));
        assertArg(typeof this.width === 'number', '`width` must be of type "number"');
        assertArg(typeof this.sensitivity === 'number', '`sensitivity` must be of type "number"');
        assertArg(typeof this.slope === 'number', '`slope` must be of type "number"');
    }
    Pulling.create = function (options) {
        var mode = options.mode || Object.keys(Pulling.modes)[0] || 'drawer';
        if (!Pulling.modes[mode]) {
            var modes = Object.keys(Pulling.modes).map(function (x) { return "\"" + x + "\""; }).join(', ');
            throw TypeError('`mode`' + " must be one of " + modes);
        }
        return new Pulling.modes[mode](options);
    };
    /** Trigger event listeners for the event */
    Pulling.prototype.emit = function (eventName, e) {
        var _this = this;
        this.handlers[eventName].forEach(function (handler) { return handler.call(_this, e); });
    };
    /** Add an event handler for the event */
    Pulling.prototype.on = function (eventName, handler) {
        this.handlers[eventName].push(handler);
        return this;
    };
    /** Remove all event handlers for an event */
    Pulling.prototype.off = function (eventName, handler) {
        if (handler) {
            this.handlers[eventName] = this.handlers[eventName].filter(function (handle) {
                return handle !== handler;
            });
        }
        else {
            this.handlers[eventName] = [];
        }
        return this;
    };
    /** Open the menu */
    Pulling.prototype.open = function (e) {
        var _this = this;
        this.emit('beforeopen', e);
        if (this.disabled) {
            return this;
        }
        if (this.state.opened) {
            return this;
        }
        this.state.closed = false;
        this.state.closing = false;
        this.state.opening = true;
        this.state.opened = false;
        var offset = this.offset();
        if (offset > 0) {
            var duration = this.timing * (1 - offset / this.width) + "ms";
            this.menu.style.transitionDuration = duration;
            this.panel.style.transitionDuration = duration;
        }
        Object.assign(this.menu.style, this.styles.open.menu);
        Object.assign(this.panel.style, this.styles.open.panel);
        var after = function () {
            _this.state.opening = false;
            _this.state.opened = true;
            Object.assign(_this.menu.style, _this.styles.open.menu);
            Object.assign(_this.panel.style, _this.styles.open.panel);
            _this.emit('opened');
        };
        if (offset === this.width) {
            after();
        }
        else {
            this.afterTransitionend(after);
        }
        return this;
    };
    /** Close the menu */
    Pulling.prototype.close = function (e) {
        var _this = this;
        this.emit('beforeclose', e);
        if (this.disabled) {
            return this;
        }
        if (this.state.closed) {
            this.state.closing = false;
            return this;
        }
        this.state.closed = false;
        this.state.closing = true;
        this.state.opening = false;
        this.state.opened = false;
        var offset = this.offset();
        if (offset > 0) {
            var duration = this.timing * offset / this.width + "ms";
            this.menu.style.transitionDuration = duration;
            this.panel.style.transitionDuration = duration;
        }
        Object.assign(this.menu.style, this.styles.closed.menu);
        Object.assign(this.panel.style, this.styles.closed.panel);
        var after = function () {
            _this.state.closing = false;
            _this.state.closed = true;
            Object.assign(_this.menu.style, _this.styles.closed.menu);
            Object.assign(_this.panel.style, _this.styles.closed.panel);
            _this.emit('closed');
        };
        if (offset === 0) {
            after();
        }
        else {
            this.afterTransitionend(after);
        }
        return this;
    };
    Pulling.prototype.toggle = function (condition) {
        if (condition === true) {
            this.open();
        }
        else if (condition === false) {
            this.close();
        }
        else {
            this.toggle(this.state.closed || this.state.closing);
        }
        return this;
    };
    /** Disable the menu functionality */
    Pulling.prototype.disable = function () {
        this.disabled = true;
        return this;
    };
    /** Enabled to menu functionality */
    Pulling.prototype.enable = function () {
        this.disabled = false;
        return this;
    };
    Pulling.prototype.afterTransitionend = function (callback) { };
    /** get offset from the default (closed) position */
    Pulling.prototype.offset = function () {
        return 0;
    };
    Pulling.modes = {};
    return Pulling;
}());

var TouchPulling$1 = /** @class */ (function (_super) {
    __extends(TouchPulling, _super);
    function TouchPulling(options) {
        var _this = _super.call(this, options) || this;
        _this.touched = false;
        _this.ignores = [];
        _this.ignoreSelector = '';
        _this.touch = options.touch !== false;
        if (_this.touch) {
            _this.addTouchEvents();
        }
        return _this;
    }
    /** set offset */
    TouchPulling.prototype.applyOffset = function (offset) { };
    TouchPulling.prototype.initTouchEvents = function () {
        var _this = this;
        var _a = this, width = _a.width, margin = _a.margin, side = _a.side, slope = _a.slope, sensitivity = _a.sensitivity, menu = _a.menu, panel = _a.panel;
        var sign = (side === 'left' ? 1 : -1);
        var startClientX = 0;
        var startClientY = 0;
        var lastClientX = 0;
        var startOffset = 0;
        var prevTime = 0;
        var lastTime = 0;
        var prevClientX = 0;
        var firstMove = false;
        var onTouchstart = function (e) {
            if (_this.ignoreSelector && e.target.matches(_this.ignoreSelector)) {
                return;
            }
            _this.emit('touchstart', e);
            if (_this.disabled) {
                return;
            }
            _this.touched = false;
            if (e.touches.length !== 1) {
                return;
            }
            var _a = e.touches[0], clientX = _a.clientX, clientY = _a.clientY;
            var offset = _this.offset();
            var region = margin + offset;
            if (side === 'left' && clientX <= region ||
                side === 'right' && window.innerWidth - clientX <= region) {
                _this.touched = true;
                startClientX = clientX;
                startClientY = clientY;
                lastClientX = clientX;
                startOffset = offset;
                lastTime = Date.now();
                firstMove = true;
            }
        };
        var onTouchmove = function (e) {
            _this.emit('touchmove', e);
            if (_this.disabled || !_this.touched) {
                return;
            }
            var _a = e.touches[0], clientX = _a.clientX, clientY = _a.clientY;
            var diffX = (clientX - startClientX) * sign;
            if (Math.abs(diffX) < 10) {
                return;
            }
            if (firstMove) {
                var diffY = clientY - startClientY;
                var currentSlope = Math.abs(diffY / diffX);
                if (currentSlope > slope) {
                    _this.touched = false;
                    return;
                }
                if (_this.state.closed && diffX > 0) {
                    _this.emit('beforeopen');
                }
                else if (_this.state.opened) {
                    _this.emit('beforeopen');
                }
                menu.style.transition = null;
                panel.style.transition = null;
            }
            if (_this.state.opened && diffX > 0 || _this.state.closed && diffX < 0) {
                lastClientX = clientX;
                lastTime = Date.now();
                return;
            }
            _this.state.opened = false;
            _this.state.closed = false;
            var dx = (clientX - lastClientX) * sign;
            var opening = dx > 0;
            _this.state.opening = opening;
            _this.state.closing = !opening;
            var offset = Math.min(Math.max(0, startOffset + diffX), width);
            _this.applyOffset(offset);
            prevClientX = lastClientX;
            lastClientX = clientX;
            prevTime = lastTime;
            lastTime = Date.now();
            firstMove = false;
        };
        var onTouchend = function (e) {
            if (!_this.touched) {
                return;
            }
            _this.touched = false;
            if (firstMove) {
                return;
            }
            _this.emit('touchend', e);
            Object.assign(_this.panel.style, _this.styles.base.panel);
            Object.assign(_this.menu.style, _this.styles.base.menu);
            var offset = _this.offset();
            var clientX = e.changedTouches[0].clientX;
            var x1;
            var t1;
            if (clientX === lastClientX) {
                x1 = prevClientX;
                t1 = prevTime;
            }
            else {
                x1 = lastClientX;
                t1 = lastTime;
            }
            var x2 = clientX;
            var t2 = Date.now();
            var speed = (x2 - x1) / (t2 - t1) * sign;
            if (offset > width / 2 &&
                speed > -sensitivity ||
                speed > sensitivity) {
                _this.open(e);
            }
            else {
                _this.close(e);
            }
        };
        return {
            onTouchstart: onTouchstart,
            onTouchmove: onTouchmove,
            onTouchend: onTouchend,
        };
    };
    TouchPulling.prototype.addTouchEvents = function () {
        if (!this.touchEvents) {
            this.touchEvents = this.initTouchEvents();
        }
        document.documentElement.addEventListener('touchstart', this.touchEvents.onTouchstart, false);
        document.documentElement.addEventListener('touchmove', this.touchEvents.onTouchmove, false);
        document.documentElement.addEventListener('touchend', this.touchEvents.onTouchend, false);
    };
    TouchPulling.prototype.removeTouchEvents = function () {
        document.documentElement.removeEventListener('touchstart', this.touchEvents.onTouchstart);
        document.documentElement.removeEventListener('touchmove', this.touchEvents.onTouchmove);
        document.documentElement.removeEventListener('touchend', this.touchEvents.onTouchend);
    };
    /** Ignore touch events from elements matching a given selector */
    TouchPulling.prototype.ignore = function (selector) {
        this.ignores.push(selector);
        this.ignoreSelector = this.ignores.join(', ');
        return this;
    };
    /**
     * Remove selector from ignore list
     * _Does not_ override `ignore`
     */
    TouchPulling.prototype.unignore = function (selector) {
        this.ignores = this.ignores.filter(function (s) { return s !== selector; });
        this.ignoreSelector = this.ignores.join(', ');
        return this;
    };
    /** enable touch functionality */
    TouchPulling.prototype.enableTouch = function () {
        if (!this.touch) {
            this.addTouchEvents();
            this.touch = true;
        }
        return this;
    };
    /** disable touch functionality */
    TouchPulling.prototype.disableTouch = function () {
        if (this.touch) {
            this.removeTouchEvents();
            this.touch = false;
        }
        return this;
    };
    return TouchPulling;
}(Pulling));

var Drawer = /** @class */ (function (_super) {
    __extends(Drawer, _super);
    function Drawer(options) {
        var _this = _super.call(this, options) || this;
        _this.styles.base.menu = (_a = {
                transition: "transform " + _this.timing + "ms " + _this.timingFunction,
                overflowX: 'hidden',
                overflowY: 'auto',
                position: 'fixed'
            }, _a[_this.side] = "-" + _this.width + "px", _a.top = '0', _a.bottom = '0', _a.width = _this.width + "px", _a.zIndex = '1', _a);
        _this.styles.open.menu = {
            transform: "translateX(" + (_this.side === 'right' ? '-' : '') + _this.width + "px)",
        };
        _this.styles.closed.menu = {
            transform: "translateX(0)",
        };
        Object.assign(_this.menu.style, _this.styles.base.menu, _this.styles.closed.menu);
        Object.assign(_this.panel.style, _this.styles.base.panel, _this.styles.closed.panel);
        _this.initTransitionend();
        return _this;
        var _a;
    }
    Drawer.prototype.offset = function () {
        var menuPos = this.menu.getBoundingClientRect();
        if (this.side === 'left') {
            return menuPos.left + this.width;
        }
        return window.innerWidth - menuPos.left;
    };
    Drawer.prototype.applyOffset = function (offset) {
        var sign = (this.side === 'left' ? 1 : -1);
        this.menu.style.transform = "translateX(" + offset * sign + "px)";
    };
    Drawer.prototype.afterTransitionend = function (callback) {
        this.onTransitionend = callback;
    };
    Drawer.prototype.initTransitionend = function () {
        var _this = this;
        this.menu.addEventListener('transitionend', function () {
            if (_this.onTransitionend) {
                _this.onTransitionend();
            }
            _this.onTransitionend = null;
        }, false);
    };
    return Drawer;
}(TouchPulling$1));
TouchPulling$1.modes['drawer'] = Drawer;

polyfill();

return TouchPulling$1;

})));
//# sourceMappingURL=pulling-drawer.js.map
